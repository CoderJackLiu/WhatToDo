name: æ„å»ºå’Œå‘å¸ƒ

on:
  # æ‰€æœ‰åˆ†æ”¯çš„ push äº‹ä»¶å’Œ Tag æ¨é€äº‹ä»¶
  push:
    branches:
      - '**'
    tags:
      - 'v*'

permissions:
  contents: write
  packages: write

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: è®¾ç½® Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: å®‰è£…ä¾èµ–
        run: npm ci

      - name: æ„å»ºåº”ç”¨
        run: npm run build -- --publish never
        env:
          ELECTRON_MIRROR: https://npmmirror.com/mirrors/electron/

      - name: æå–ç‰ˆæœ¬å·
        id: version
        run: |
          $version = (Get-Content package.json | ConvertFrom-Json).version
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "ç‰ˆæœ¬å·: $version"

      - name: æŸ¥æ‰¾æ„å»ºäº§ç‰©
        id: find-artifact
        run: |
          $exeFile = Get-ChildItem -Path dist -Filter *.exe -Recurse | Select-Object -First 1
          if ($exeFile) {
            $fileName = $exeFile.Name
            $filePath = $exeFile.FullName
            echo "file_name=$fileName" >> $env:GITHUB_OUTPUT
            echo "file_path=$filePath" >> $env:GITHUB_OUTPUT
            echo "æ‰¾åˆ°æ„å»ºäº§ç‰©: $fileName"
          } else {
            echo "é”™è¯¯: æœªæ‰¾åˆ° exe æ–‡ä»¶"
            exit 1
          }

      - name: ä¸Šä¼ åˆ° GitHub Packages
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $packageName = "todolist-${{ steps.version.outputs.version }}-${{ github.sha }}.exe"
          $packagePath = "${{ steps.find-artifact.outputs.file_path }}"
          
          # é‡å‘½åæ–‡ä»¶
          $newPath = Join-Path (Split-Path $packagePath) $packageName
          Copy-Item $packagePath $newPath -Force
          
          # å‡†å¤‡å‘å¸ƒåˆ° GitHub Packages
          $repoParts = "${{ github.repository }}".Split('/')
          $owner = $repoParts[0].ToLower()  # GitHub Packages è¦æ±‚åŒ…åå…¨å°å†™
          $repo = $repoParts[1].ToLower()   # GitHub Packages è¦æ±‚åŒ…åå…¨å°å†™
          $version = "${{ steps.version.outputs.version }}"
          
          # åŒ…ååŒ…å«ç‰ˆæœ¬å·ï¼Œå®ç°æŒ‰ç‰ˆæœ¬å·åˆ†ç»„
          $packageNameWithVersion = "$repo-$version"
          $packageDir = "pkg-temp"
          
          # åˆ›å»ºä¸´æ—¶åŒ…ç›®å½•
          New-Item -ItemType Directory -Path $packageDir -Force | Out-Null
          
          # å¤åˆ¶ exe æ–‡ä»¶åˆ°åŒ…ç›®å½•
          Copy-Item $newPath "$packageDir/$packageName"
          
          # åˆ›å»º package.json ç”¨äºå‘å¸ƒ
          # åŒ…åæ ¼å¼ï¼š@owner/repo-1.0.0
          # ç‰ˆæœ¬å·ï¼šä½¿ç”¨ commit SHA çš„å‰8ä½
          $commitSha = "${{ github.sha }}"
          $versionSuffix = $commitSha.Substring(0, [Math]::Min(8, $commitSha.Length))
          $pkgJson = @{
            name = "@$owner/$packageNameWithVersion"
            version = "0.0.0-$versionSuffix"
            description = "TodoList $version æ„å»ºäº§ç‰© - ${{ github.sha }}"
            main = $packageName
            files = @($packageName)
            publishConfig = @{
              registry = "https://npm.pkg.github.com"
            }
          } | ConvertTo-Json
          
          $pkgJson | Out-File -FilePath "$packageDir/package.json" -Encoding utf8
          
          # é…ç½® npm registry å’Œè®¤è¯
          # æ³¨æ„ï¼šscope éœ€è¦åŒ¹é…åŒ…åï¼Œä½†ç”±äºåŒ…ååŒ…å«ç‰ˆæœ¬å·ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨é€šé…ç¬¦æˆ–ä¸ºæ¯ä¸ªåŒ…å•ç‹¬é…ç½®
          # è¿™é‡Œä½¿ç”¨ owner scopeï¼Œnpm ä¼šè‡ªåŠ¨å¤„ç†å­åŒ…
          $npmrcContent = "@$owner`:registry=https://npm.pkg.github.com`n//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}"
          $npmrcContent | Out-File -FilePath "$packageDir/.npmrc" -Encoding utf8
          
          # å‘å¸ƒåˆ° GitHub Packages
          Push-Location $packageDir
          try {
            npm publish
            echo "âœ… å·²ä¸Šä¼ åˆ° GitHub Packages: @$owner/$packageNameWithVersion@0.0.0-$versionSuffix"
            echo "ğŸ”— æŸ¥çœ‹åœ°å€: https://github.com/${{ github.repository }}/packages"
          } catch {
            Write-Error "âŒ å‘å¸ƒå¤±è´¥: $_"
            exit 1
          } finally {
            Pop-Location
            Remove-Item -Path $packageDir -Recurse -Force -ErrorAction SilentlyContinue
          }

      - name: ä¿å­˜æ„å»ºäº§ç‰©
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: ${{ steps.find-artifact.outputs.file_path }}
          retention-days: 30

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # è·å–å®Œæ•´å†å²ç”¨äºæŸ¥æ‰¾ä¸Šä¸€ä¸ª tag

      - name: è®¾ç½® Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: æå–ç‰ˆæœ¬å·
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ç‰ˆæœ¬å·: $VERSION"

      - name: ä¸‹è½½æ„å»ºäº§ç‰©
        uses: actions/download-artifact@v4
        with:
          name: build-artifact
          path: ./artifacts

      - name: æŸ¥æ‰¾ exe æ–‡ä»¶
        id: find-exe
        run: |
          # æŸ¥æ‰¾æ‰€æœ‰ exe æ–‡ä»¶
          EXE_FILE=$(find artifacts -name "*.exe" -type f | head -n 1)
          if [ -z "$EXE_FILE" ]; then
            echo "é”™è¯¯: æœªæ‰¾åˆ° exe æ–‡ä»¶"
            echo "å½“å‰ç›®å½•å†…å®¹:"
            ls -la artifacts/ || true
            exit 1
          fi
          EXE_NAME=$(basename "$EXE_FILE")
          echo "file_name=$EXE_NAME" >> $GITHUB_OUTPUT
          echo "file_path=$EXE_FILE" >> $GITHUB_OUTPUT
          echo "æ‰¾åˆ°æ–‡ä»¶: $EXE_NAME (è·¯å¾„: $EXE_FILE)"

      - name: å‡†å¤‡ Release æ–‡ä»¶
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          NEW_NAME="TodoList-${TAG_NAME}.exe"
          mkdir -p dist
          cp "${{ steps.find-exe.outputs.file_path }}" "dist/$NEW_NAME"
          echo "NEW_NAME=$NEW_NAME" >> $GITHUB_ENV
          echo "å·²å‡†å¤‡æ–‡ä»¶: dist/$NEW_NAME"

      - name: è·å–ä¸Šä¸€ä¸ª Tag
        id: previous-tag
        run: |
          # è·å–æ‰€æœ‰ tagsï¼ŒæŒ‰ç‰ˆæœ¬å·æ’åº
          PREV_TAG=$(git tag --sort=-version:refname | sed -n '2p' || echo "")
          if [ -z "$PREV_TAG" ]; then
            echo "æ²¡æœ‰æ‰¾åˆ°ä¸Šä¸€ä¸ª tagï¼Œå°†ç”Ÿæˆå®Œæ•´å˜æ›´æ—¥å¿—"
            echo "previous_tag=" >> $GITHUB_OUTPUT
          else
            echo "ä¸Šä¸€ä¸ª tag: $PREV_TAG"
            echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          fi

      - name: ç”Ÿæˆ Release Notes
        id: release-notes
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tagName = '${{ github.ref_name }}';
            const previousTag = '${{ steps.previous-tag.outputs.previous_tag }}';
            const tagVersion = tagName.replace(/^v/, '');
            
            try {
              // è·å–æäº¤è®°å½•
              let commits = [];
              if (previousTag && previousTag.trim() !== '') {
                // è·å–ä¸¤ä¸ª tag ä¹‹é—´çš„æäº¤
                const { data: compare } = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: previousTag,
                  head: tagName,
                });
                commits = compare.commits || [];
              } else {
                // å¦‚æœæ²¡æœ‰ä¸Šä¸€ä¸ª tagï¼Œè·å–æœ€è¿‘çš„æäº¤ï¼ˆæœ€å¤š100æ¡ï¼‰
                const { data: commitList } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: tagName,
                  per_page: 100,
                });
                commits = commitList || [];
              }
              
              // åˆ†ç±»æäº¤
              const features = [];
              const fixes = [];
              const docs = [];
              const refactor = [];
              const chore = [];
              const others = [];
              
              commits.forEach(commit => {
                const message = commit.commit.message.split('\n')[0]; // åªå–ç¬¬ä¸€è¡Œ
                const author = commit.commit.author.name;
                const sha = commit.sha.substring(0, 7);
                const url = commit.html_url;
                
                const item = `- ${message} ([${sha}](${url})) - ${author}`;
                
                const lowerMessage = message.toLowerCase();
                if (lowerMessage.startsWith('feat') || lowerMessage.startsWith('feature') || lowerMessage.includes('æ–°åŠŸèƒ½') || lowerMessage.includes('æ·»åŠ ')) {
                  features.push(item);
                } else if (lowerMessage.startsWith('fix') || lowerMessage.startsWith('bugfix') || lowerMessage.includes('ä¿®å¤')) {
                  fixes.push(item);
                } else if (lowerMessage.startsWith('docs') || lowerMessage.includes('æ–‡æ¡£')) {
                  docs.push(item);
                } else if (lowerMessage.startsWith('refactor') || lowerMessage.includes('é‡æ„')) {
                  refactor.push(item);
                } else if (lowerMessage.startsWith('chore') || lowerMessage.startsWith('ci') || lowerMessage.includes('æ„å»º')) {
                  chore.push(item);
                } else {
                  others.push(item);
                }
              });
              
              // æ„å»º Release Notes
              // ä½¿ç”¨æ•°ç»„æ„å»ºï¼Œç¡®ä¿æ¢è¡Œç¬¦æ­£ç¡®
              const notesLines = [`## TodoList ${tagVersion}`, ''];
              
              if (commits.length === 0) {
                notesLines.push('### å˜æ›´', '- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ', '');
              } else {
                if (features.length > 0) {
                  notesLines.push('### âœ¨ æ–°åŠŸèƒ½', '');
                  features.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (fixes.length > 0) {
                  notesLines.push('### ğŸ› ä¿®å¤', '');
                  fixes.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (refactor.length > 0) {
                  notesLines.push('### â™»ï¸ é‡æ„', '');
                  refactor.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (docs.length > 0) {
                  notesLines.push('### ğŸ“ æ–‡æ¡£', '');
                  docs.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (chore.length > 0) {
                  notesLines.push('### ğŸ”§ æ„å»º/å·¥å…·', '');
                  chore.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (others.length > 0) {
                  notesLines.push('### ğŸ“¦ å…¶ä»–å˜æ›´', '');
                  others.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
              }
              
              // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
              if (commits.length > 0) {
                const compareUrl = previousTag 
                  ? `https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...${tagName}`
                  : `https://github.com/${context.repo.owner}/${context.repo.repo}/commits/${tagName}`;
                notesLines.push('---', '', `**ç»Ÿè®¡**: å…± ${commits.length} ä¸ªæäº¤`, '', `æŸ¥çœ‹ [å®Œæ•´å˜æ›´æ—¥å¿—](${compareUrl})`);
              }
              
              const notes = notesLines.join('\n');
              
              // æ·»åŠ ä¸‹è½½é“¾æ¥
              const downloadSection = `\n\n---\n\n### ä¸‹è½½\n- [TodoList-${tagName}.exe](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${tagName}/TodoList-${tagName}.exe)`;
              const fullNotes = notes + downloadSection;
              
              // ç›´æ¥å†™å…¥æ–‡ä»¶ï¼Œç¡®ä¿æ¢è¡Œç¬¦æ­£ç¡®ä¿ç•™
              const fs = require('fs');
              fs.writeFileSync('release-notes.md', fullNotes, 'utf8');
              
              // ä½¿ç”¨å¤šè¡Œè¾“å‡ºæ ¼å¼ï¼Œé¿å…æ¢è¡Œç¬¦è¢«è½¬ä¹‰
              // å‚è€ƒï¼šhttps://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
              const delimiter = 'EOF_RELEASE_NOTES';
              console.log(`result<<${delimiter}`);
              console.log(fullNotes);
              console.log(delimiter);
              
              return fullNotes;
            } catch (error) {
              // å¦‚æœç”Ÿæˆå¤±è´¥ï¼Œè¿”å›é»˜è®¤å†…å®¹
              console.error('ç”Ÿæˆ Release Notes å¤±è´¥:', error);
              const compareUrl = previousTag 
                ? `https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...${tagName}`
                : `https://github.com/${context.repo.owner}/${context.repo.repo}/commits/${tagName}`;
              const fallbackNotes = `## TodoList ${tagVersion}\n\n### å˜æ›´\n- æŸ¥çœ‹ [æäº¤å†å²](${compareUrl})`;
              core.setOutput('result', fallbackNotes);
              return fallbackNotes;
            }


      - name: åˆ›å»º GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*.exe
          tag_name: ${{ github.ref_name }}
          name: Release ${{ steps.version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

