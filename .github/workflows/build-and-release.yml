name: Build and Release

on:
  # Push events on all branches and tag push events
  push:
    branches:
      - '**'
    tags:
      - 'v*'

permissions:
  contents: write
  packages: write

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build -- --publish never
        env:
          ELECTRON_MIRROR: https://npmmirror.com/mirrors/electron/

      - name: Extract version
        id: version
        run: |
          $version = (Get-Content package.json | ConvertFrom-Json).version
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Version: $version"

      - name: Find build artifacts
        id: find-artifact
        run: |
          $exeFile = Get-ChildItem -Path dist -Filter *.exe -Recurse | Select-Object -First 1
          if ($exeFile) {
            $fileName = $exeFile.Name
            $filePath = $exeFile.FullName
            echo "file_name=$fileName" >> $env:GITHUB_OUTPUT
            echo "file_path=$filePath" >> $env:GITHUB_OUTPUT
            echo "Found build artifact: $fileName"
          } else {
            echo "Error: exe file not found"
            exit 1
          }

      - name: Upload to GitHub Packages
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $packageName = "todolist-${{ steps.version.outputs.version }}-${{ github.sha }}.exe"
          $packagePath = "${{ steps.find-artifact.outputs.file_path }}"
          
          # Rename file
          $newPath = Join-Path (Split-Path $packagePath) $packageName
          Copy-Item $packagePath $newPath -Force
          
          # Prepare for publishing to GitHub Packages
          $repoParts = "${{ github.repository }}".Split('/')
          $owner = $repoParts[0].ToLower()  # GitHub Packages requires lowercase package names
          $repo = $repoParts[1].ToLower()   # GitHub Packages requires lowercase package names
          $version = "${{ steps.version.outputs.version }}"
          
          # Package name includes version number for grouping by version
          $packageNameWithVersion = "$repo-$version"
          $packageDir = "pkg-temp"
          
          # Create temporary package directory
          New-Item -ItemType Directory -Path $packageDir -Force | Out-Null
          
          # Copy exe file to package directory
          Copy-Item $newPath "$packageDir/$packageName"
          
          # Create package.json for publishing
          # Package name format: @owner/repo-1.0.0
          # Version: use first 8 characters of commit SHA
          $commitSha = "${{ github.sha }}"
          $versionSuffix = $commitSha.Substring(0, [Math]::Min(8, $commitSha.Length))
          $pkgJson = @{
            name = "@$owner/$packageNameWithVersion"
            version = "0.0.0-$versionSuffix"
            description = "TodoList $version build artifact - ${{ github.sha }}"
            main = $packageName
            files = @($packageName)
            publishConfig = @{
              registry = "https://npm.pkg.github.com"
            }
          } | ConvertTo-Json
          
          $pkgJson | Out-File -FilePath "$packageDir/package.json" -Encoding utf8
          
          # Configure npm registry and authentication
          # Note: scope needs to match package name, but since package name includes version, we need to use wildcard or configure separately
          # Here we use owner scope, npm will automatically handle sub-packages
          $npmrcContent = "@$owner`:registry=https://npm.pkg.github.com`n//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}"
          $npmrcContent | Out-File -FilePath "$packageDir/.npmrc" -Encoding utf8
          
          # Publish to GitHub Packages
          Push-Location $packageDir
          try {
            npm publish
            echo "âœ… Uploaded to GitHub Packages: @$owner/$packageNameWithVersion@0.0.0-$versionSuffix"
            echo "ðŸ”— View at: https://github.com/${{ github.repository }}/packages"
          } catch {
            Write-Error "âŒ Publish failed: $_"
            exit 1
          } finally {
            Pop-Location
            Remove-Item -Path $packageDir -Recurse -Force -ErrorAction SilentlyContinue
          }

      - name: Create Pre-Release and Update Packages Directory
        if: ${{ !startsWith(github.ref, 'refs/tags/') }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const version = '${{ steps.version.outputs.version }}';
            const commitSha = '${{ github.sha }}';
            const shortSha = commitSha.substring(0, 8);
            const branch = '${{ github.ref_name }}';
            const repo = '${{ github.repository }}';
            const [owner, repoName] = repo.split('/');
            
            // Find the exe file
            const exePath = '${{ steps.find-artifact.outputs.file_path }}';
            const packageName = `todolist-${version}-${shortSha}.exe`;
            
            // Read the exe file
            const exeBuffer = fs.readFileSync(exePath);
            
            // Create a pre-release for storing build artifacts
            const releaseName = `Build ${version} (${shortSha})`;
            const releaseTag = `build-${version}-${shortSha}`;
            
            try {
              // Check if release tag already exists
              let release;
              try {
                const { data: existingRelease } = await github.rest.repos.getReleaseByTag({
                  owner: owner,
                  repo: repoName,
                  tag: releaseTag
                });
                release = existingRelease;
                console.log(`Pre-release ${releaseTag} already exists`);
              } catch (error) {
                if (error.status === 404) {
                  // Create new pre-release
                  const { data: newRelease } = await github.rest.repos.createRelease({
                    owner: owner,
                    repo: repoName,
                    tag_name: releaseTag,
                    name: releaseName,
                    body: `Auto-built artifact - Version ${version}\n\nCommit: ${commitSha}\nBranch: ${branch}\n\nThis is an auto-built pre-release version for providing download links.`,
                    draft: false,
                    prerelease: true
                  });
                  release = newRelease;
                  console.log(`Created pre-release ${releaseTag}`);
                } else {
                  throw error;
                }
              }
              
              // Check if asset already exists
              const assetName = packageName;
              let asset = null;
              try {
                const { data: assets } = await github.rest.repos.listReleaseAssets({
                  owner: owner,
                  repo: repoName,
                  release_id: release.id
                });
                asset = assets.find(a => a.name === assetName);
                if (asset) {
                  console.log(`Asset ${assetName} already exists: ${asset.browser_download_url}`);
                }
              } catch (error) {
                console.warn('Warning: Could not list assets:', error.message);
              }
              
              // Upload asset if it doesn't exist
              if (!asset) {
                try {
                  const { data: newAsset } = await github.rest.repos.uploadReleaseAsset({
                    owner: owner,
                    repo: repoName,
                    release_id: release.id,
                    name: assetName,
                    data: exeBuffer
                  });
                  asset = newAsset;
                  console.log(`âœ… Uploaded asset: ${asset.browser_download_url}`);
                } catch (error) {
                  console.error('Failed to upload asset:', error);
                  throw error;
                }
              }
              
              // Ensure asset exists
              if (!asset || !asset.browser_download_url) {
                throw new Error('Failed to get asset download URL');
              }
              
              // Update packages/README.md using GitHub API
              const readmePath = 'packages/README.md';
              const downloadUrl = asset.browser_download_url;
              const readmeLines = [
                '# Build Artifacts Download',
                '',
                '## Latest Build',
                '',
                '- **Version**: ' + version,
                '- **Commit**: [' + shortSha + '](https://github.com/' + repo + '/commit/' + commitSha + ')',
                '- **Branch**: ' + branch,
                '- **Build Time**: ' + new Date().toISOString(),
                '',
                '### Download Link',
                '',
                '- [' + packageName + '](' + downloadUrl + ')',
                '',
                '---',
                '',
                '## Description',
                '',
                'This directory contains auto-built artifacts. Each push will automatically build and upload the latest installer.',
                '',
                '### How to Download',
                '',
                '1. Click the download link above',
                '2. After downloading, double-click to run the installer',
                '',
                '### Previous Versions',
                '',
                'Previous versions can be viewed on the [GitHub Releases](https://github.com/' + repo + '/releases) page.'
              ];
              const readmeContent = readmeLines.join('\n');
              
              const readmeContentBase64 = Buffer.from(readmeContent, 'utf8').toString('base64');
              
              try {
                // Try to get existing file to get its SHA
                let fileSha = null;
                try {
                  const { data: existingFile } = await github.rest.repos.getContent({
                    owner: owner,
                    repo: repoName,
                    path: readmePath,
                    ref: branch
                  });
                  
                  // Handle both array and object responses
                  const fileData = Array.isArray(existingFile) ? existingFile[0] : existingFile;
                  if (fileData && fileData.sha) {
                    fileSha = fileData.sha;
                  }
                } catch (error) {
                  if (error.status !== 404) {
                    console.warn('Warning: Could not get existing file:', error.message);
                  }
                  // File doesn't exist, will create new one
                }
                
                // Create or update file
                const updateParams = {
                  owner: owner,
                  repo: repoName,
                  path: readmePath,
                  message: `docs: Update packages directory download link [skip ci]`,
                  content: readmeContentBase64,
                  branch: branch
                };
                
                if (fileSha) {
                  updateParams.sha = fileSha;
                }
                
                await github.rest.repos.createOrUpdateFileContents(updateParams);
                
                console.log('âœ… Updated packages/README.md via GitHub API');
              } catch (error) {
                console.error('Failed to update README via API:', error);
                throw error;
              }
              
            } catch (error) {
              console.error('âŒ Error:', error);
              throw error;
            }

      - name: Save build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: ${{ steps.find-artifact.outputs.file_path }}
          retention-days: 30

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for finding previous tag

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: Extract version
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifact
          path: ./artifacts

      - name: Find exe file
        id: find-exe
        run: |
          # Find all exe files
          EXE_FILE=$(find artifacts -name "*.exe" -type f | head -n 1)
          if [ -z "$EXE_FILE" ]; then
            echo "Error: exe file not found"
            echo "Current directory contents:"
            ls -la artifacts/ || true
            exit 1
          fi
          EXE_NAME=$(basename "$EXE_FILE")
          echo "file_name=$EXE_NAME" >> $GITHUB_OUTPUT
          echo "file_path=$EXE_FILE" >> $GITHUB_OUTPUT
          echo "Found file: $EXE_NAME (path: $EXE_FILE)"

      - name: Prepare Release files
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          NEW_NAME="TodoList-${TAG_NAME}.exe"
          mkdir -p dist
          cp "${{ steps.find-exe.outputs.file_path }}" "dist/$NEW_NAME"
          echo "NEW_NAME=$NEW_NAME" >> $GITHUB_ENV
          echo "Prepared file: dist/$NEW_NAME"

      - name: Upload to GitHub Packages
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          PACKAGE_NAME="todolist-${{ steps.version.outputs.version }}-${TAG_NAME}.exe"
          PACKAGE_PATH="dist/TodoList-${TAG_NAME}.exe"
          
          # Prepare for publishing to GitHub Packages
          REPO_PARTS="${{ github.repository }}"
          OWNER=$(echo "$REPO_PARTS" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]')
          REPO=$(echo "$REPO_PARTS" | cut -d'/' -f2 | tr '[:upper:]' '[:lower:]')
          VERSION="${{ steps.version.outputs.version }}"
          
          # Package name includes version number for grouping by version
          PACKAGE_NAME_WITH_VERSION="${REPO}-${VERSION}"
          PACKAGE_DIR="pkg-temp"
          
          # Create temporary package directory
          mkdir -p "$PACKAGE_DIR"
          
          # Copy exe file to package directory
          cp "$PACKAGE_PATH" "$PACKAGE_DIR/$PACKAGE_NAME"
          
          # Create package.json for publishing
          # Package name format: @owner/repo-1.0.0
          # Version: use tag name (remove 'v' prefix if exists)
          VERSION_SUFFIX=$(echo "$TAG_NAME" | sed 's/^v//')
          printf '{\n  "name": "@%s/%s",\n  "version": "%s",\n  "description": "TodoList %s release artifact - %s",\n  "main": "%s",\n  "files": ["%s"],\n  "publishConfig": {\n    "registry": "https://npm.pkg.github.com"\n  }\n}' \
            "$OWNER" "$PACKAGE_NAME_WITH_VERSION" "$VERSION_SUFFIX" "$VERSION" "$TAG_NAME" "$PACKAGE_NAME" "$PACKAGE_NAME" > "$PACKAGE_DIR/package.json"
          
          # Configure npm registry and authentication
          echo "@${OWNER}:registry=https://npm.pkg.github.com" > "$PACKAGE_DIR/.npmrc"
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}" >> "$PACKAGE_DIR/.npmrc"
          
          # Publish to GitHub Packages
          cd "$PACKAGE_DIR"
          npm publish || {
            echo "âŒ Publish failed"
            exit 1
          }
          echo "âœ… Uploaded to GitHub Packages: @${OWNER}/${PACKAGE_NAME_WITH_VERSION}@${VERSION_SUFFIX}"
          echo "ðŸ”— View at: https://github.com/${{ github.repository }}/packages"
          cd ..
          rm -rf "$PACKAGE_DIR"

      - name: Get previous tag
        id: previous-tag
        run: |
          # Get all tags, sorted by version
          PREV_TAG=$(git tag --sort=-version:refname | sed -n '2p' || echo "")
          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found, will generate full changelog"
            echo "previous_tag=" >> $GITHUB_OUTPUT
          else
            echo "Previous tag: $PREV_TAG"
            echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Generate Release Notes
        id: release-notes
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tagName = '${{ github.ref_name }}';
            const previousTag = '${{ steps.previous-tag.outputs.previous_tag }}';
            const tagVersion = tagName.replace(/^v/, '');
            
            try {
              // Get commit records
              let commits = [];
              if (previousTag && previousTag.trim() !== '') {
                // Get commits between two tags
                const { data: compare } = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: previousTag,
                  head: tagName,
                });
                commits = compare.commits || [];
              } else {
                // If no previous tag, get recent commits (max 100)
                const { data: commitList } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: tagName,
                  per_page: 100,
                });
                commits = commitList || [];
              }
              
              // Categorize commits
              const features = [];
              const fixes = [];
              const docs = [];
              const refactor = [];
              const chore = [];
              const others = [];
              
              commits.forEach(commit => {
                const message = commit.commit.message.split('\n')[0]; // Only take first line
                const author = commit.commit.author.name;
                const sha = commit.sha.substring(0, 7);
                const url = commit.html_url;
                
                const item = `- ${message} ([${sha}](${url})) - ${author}`;
                
                const lowerMessage = message.toLowerCase();
                if (lowerMessage.startsWith('feat') || lowerMessage.startsWith('feature') || lowerMessage.includes('add') || lowerMessage.includes('new')) {
                  features.push(item);
                } else if (lowerMessage.startsWith('fix') || lowerMessage.startsWith('bugfix') || lowerMessage.includes('bug')) {
                  fixes.push(item);
                } else if (lowerMessage.startsWith('docs') || lowerMessage.includes('documentation')) {
                  docs.push(item);
                } else if (lowerMessage.startsWith('refactor')) {
                  refactor.push(item);
                } else if (lowerMessage.startsWith('chore') || lowerMessage.startsWith('ci') || lowerMessage.includes('build')) {
                  chore.push(item);
                } else {
                  others.push(item);
                }
              });
              
              // Build Release Notes
              // Use array to build, ensuring line breaks are correct
              const notesLines = [`## TodoList ${tagVersion}`, ''];
              
              if (commits.length === 0) {
                notesLines.push('### Changes', '- Initial release', '');
              } else {
                if (features.length > 0) {
                  notesLines.push('### âœ¨ Features', '');
                  features.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (fixes.length > 0) {
                  notesLines.push('### ðŸ› Fixes', '');
                  fixes.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (refactor.length > 0) {
                  notesLines.push('### â™»ï¸ Refactor', '');
                  refactor.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (docs.length > 0) {
                  notesLines.push('### ðŸ“ Documentation', '');
                  docs.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (chore.length > 0) {
                  notesLines.push('### ðŸ”§ Build/Tools', '');
                  chore.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
                if (others.length > 0) {
                  notesLines.push('### ðŸ“¦ Other Changes', '');
                  others.forEach(item => {
                    notesLines.push(item, '');
                  });
                }
              }
              
              // Add statistics
              if (commits.length > 0) {
                const compareUrl = previousTag 
                  ? `https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...${tagName}`
                  : `https://github.com/${context.repo.owner}/${context.repo.repo}/commits/${tagName}`;
                notesLines.push('---', '', `**Statistics**: ${commits.length} commits`, '', `View [full changelog](${compareUrl})`);
              }
              
              const notes = notesLines.join('\n');
              
              // Add download link
              const downloadSection = `\n\n---\n\n### Download\n- [TodoList-${tagName}.exe](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${tagName}/TodoList-${tagName}.exe)`;
              const fullNotes = notes + downloadSection;
              
              // Write directly to file, ensuring line breaks are preserved
              const fs = require('fs');
              fs.writeFileSync('release-notes.md', fullNotes, 'utf8');
              
              // Use multiline output format to avoid line break escaping
              // Reference: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
              const delimiter = 'EOF_RELEASE_NOTES';
              console.log(`result<<${delimiter}`);
              console.log(fullNotes);
              console.log(delimiter);
              
              return fullNotes;
            } catch (error) {
              // If generation fails, return default content
              console.error('Failed to generate Release Notes:', error);
              const compareUrl = previousTag 
                ? `https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...${tagName}`
                : `https://github.com/${context.repo.owner}/${context.repo.repo}/commits/${tagName}`;
              const fallbackNotes = `## TodoList ${tagVersion}\n\n### Changes\n- View [commit history](${compareUrl})`;
              core.setOutput('result', fallbackNotes);
              return fallbackNotes;
            }


      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*.exe
          tag_name: ${{ github.ref_name }}
          name: Release ${{ steps.version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

